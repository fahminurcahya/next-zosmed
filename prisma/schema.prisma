// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["multiSchema"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  schemas  = ["zosmed"]
}

// Tambahkan model ini ke schema.prisma Anda

model Waitinglist {
  id             String            @id @default(cuid())
  email          String            @unique
  name           String
  phone          String?
  referralSource String?           @map("referral_source") // dari mana tau (IG, teman, dll)
  interestedPlan SUBSCRIPTION_PLAN @default(FREE) @map("interested_plan")
  isNotified     Boolean           @default(false) @map("is_notified")
  notifiedAt     DateTime?         @map("notified_at")
  ipAddress      String?           @map("ip_address")
  userAgent      String?           @map("user_agent")
  metadata       Json? // additional info
  discountCode   DiscountCode?
  createdAt      DateTime          @default(now()) @map("created_at")
  updatedAt      DateTime          @updatedAt @map("updated_at")

  @@index([email])
  @@index([isNotified])
  @@map("waiting_list")
  @@schema("zosmed")
}

model User {
  id                    String            @id
  name                  String
  email                 String
  emailVerified         Boolean           @map("email_verified")
  image                 String?
  role                  String            @default("customer")
  phone                 String?
  hasOnboarding         Boolean           @default(false) @map("has_onboarding")
  businessName          String?           @map("business_name")
  businessCategory      BusinessCategory? @map("business_category")
  businessSize          BusinessSize?     @map("business_size")
  location              String?
  goals                 String?
  onboardingStep        OnboardingStep    @default(BUSINESS_INFO) @map("onboarding_step")
  onboardingCompletedAt DateTime?         @map("onboarding_completed_at")
  agreements            Boolean           @default(false)
  createdAt             DateTime          @map("created_at")
  updatedAt             DateTime          @map("updated_at")
  sessions              Session[]
  accounts              Account[]
  subscription          Subscription?
  integration           Integration[]
  notification          Notification[]
  workflows             Workflow[]
  usageTracking         UsageTracking[]
  discountUsage         DiscountUsage[]
  payment               Payment[]
  recurringPlan         RecurringPlan[]
  paymentMethod         PaymentMethod[]

  @@unique([email])
  @@map("user")
  @@schema("zosmed")
}

enum BusinessCategory {
  FB // Food & Beverage
  FASHION // Fashion & Apparel
  EDUCATION // Education & Training
  HEALTH // Health & Wellness
  TECHNOLOGY // Technology & Digital
  RETAIL // Retail & E-commerce
  OTHER // Other

  @@map("business_categories")
  @@schema("zosmed")
}

enum BusinessSize {
  SOLO // Solo/Personal (1 person)
  SMALL // Small Business (2-10 employees)
  MEDIUM // Medium Business (11-50 employees)
  LARGE // Large Enterprise (50+ employees)

  @@map("business_sizes")
  @@schema("zosmed")
}

enum OnboardingStep {
  BUSINESS_INFO // Step 1: Business information
  INSTAGRAM_CONNECTION // Step 2: Instagram connection
  COMPLETED // Onboarding completed

  @@map("onboarding_steps")
  @@schema("zosmed")
}

model Session {
  id        String   @id
  expiresAt DateTime @map("expires_at")
  token     String
  createdAt DateTime @map("created_at")
  updatedAt DateTime @map("updated_at")
  ipAddress String?  @map("ip_address")
  userAgent String?  @map("user_agent")
  userId    String   @map("user_id")
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@map("session")
  @@schema("zosmed")
}

model Account {
  id                    String    @id
  accountId             String    @map("account_id")
  providerId            String    @map("provider_id")
  userId                String    @map("user_id")
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?   @map("access_token")
  refreshToken          String?   @map("refresh_token")
  idToken               String?   @map("id_token")
  accessTokenExpiresAt  DateTime? @map("access_token_expires_at")
  refreshTokenExpiresAt DateTime? @map("refresh_token_expires_at")
  scope                 String?
  password              String?
  createdAt             DateTime  @map("created_at")
  updatedAt             DateTime  @map("updated_at")

  @@map("account")
  @@schema("zosmed")
}

model Verification {
  id         String    @id
  identifier String
  value      String
  expiresAt  DateTime  @map("expires_at")
  createdAt  DateTime? @map("created_at")
  updatedAt  DateTime? @map("updated_at")

  @@map("verification")
  @@schema("zosmed")
}

model Subscription {
  id             String            @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user           User?             @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId         String?           @unique @map("user_id")
  createdAt      DateTime          @default(now()) @map("created_at")
  plan           SUBSCRIPTION_PLAN @default(FREE)
  updatedAt      DateTime          @default(now()) @map("updated_at")
  // Limits & Usage
  maxAccounts    Int               @default(1) @map("max_accounts")
  maxDMPerMonth  Int               @default(100) @map("max_dm_per_month")
  currentDMCount Int               @default(0) @map("current_dm_count")
  dmResetDate    DateTime          @default(now()) @map("dm_reset_date")

  // AI Features
  hasAIReply          Boolean @default(false) @map("has_ai_reply")
  hasAISalesPredictor Boolean @default(false) @map("has_ai_sales_predictor")
  maxAIReplyPerMonth  Int     @default(100) @map("max_ai_reply_per_month")
  currentAICount      Int     @default(0) @map("current_ai_count")

  // Billing
  status             SubscriptionStatus @default(ACTIVE)
  currentPeriodStart DateTime?          @map("current_period_start")
  currentPeriodEnd   DateTime?          @map("current_period_end")
  cancelAtPeriodEnd  Boolean            @default(false) @map("cancel_at_period_end")

  // Link to pricing plan
  pricingPlan   PricingPlan? @relation(fields: [pricingPlanId], references: [id])
  pricingPlanId String?      @map("pricing_plan_id")
  customPlan    Json?        @map("custom_plan") // For custom/legacy plans

  isRecurring     Boolean?       @default(false) @map("is_recurring")
  recurringPlanId String?        @unique @map("recurring_plan_id")
  recurringPlan   RecurringPlan?
  lastPaymentAt   DateTime?      @map("last_payment_at")

  metadata Json?

  @@map("subscription")
  @@schema("zosmed")
}

enum SUBSCRIPTION_PLAN {
  FREE // Rp 0 - 1 akun, 100 DM
  STARTER // Rp 99k - 3 akun, 2000 DM, AI terbatas
  PRO // Rp 199k - 10 akun, 10k DM, full AI

  @@schema("zosmed")
}

enum SubscriptionStatus {
  ACTIVE
  INACTIVE
  PAST_DUE
  CANCELED

  @@schema("zosmed")
}

model Integration {
  id              String           @id @default(cuid())
  userId          String           @map("user_id")
  user            User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  type            INTEGRATION_TYPE @default(INSTAGRAM)
  accountUsername String           @map("account_username")
  accountId       String           @unique @map("account_id") // Instagram account ID
  accessToken     String           @map("access_token") @db.Text
  refreshToken    String?          @map("refresh_token") @db.Text
  tokenType       String?          @map("token_type")
  scope           String?
  expiresAt       DateTime?        @map("expires_at")
  lastSyncAt      DateTime?        @map("last_sync_at")
  workflows       Workflow[]
  comments        Comment[]
  messages        DirectMessage[]
  createdAt       DateTime         @default(now()) @map("created_at")
  updatedAt       DateTime         @updatedAt @map("updated_at")
  usageTracking   UsageTracking[]

  @@unique([userId, accountId])
  @@index([userId])
  @@map("integration")
  @@schema("zosmed")
}

enum INTEGRATION_TYPE {
  INSTAGRAM

  @@schema("zosmed")
}

model DirectMessage {
  id            String      @id @default(cuid())
  integrationId String      @map("integration_id")
  integration   Integration @relation(fields: [integrationId], references: [id], onDelete: Cascade)

  // Message identifiers
  messageId String @unique @map("message_id")
  threadId  String @map("thread_id")

  // Direction of message
  direction MessageDirection @default(INCOMING) // INCOMING or OUTGOING

  // For INCOMING messages:
  // - senderId = Instagram user who sent the message
  // - recipientId = Our Instagram account (integration)
  // For OUTGOING messages:
  // - senderId = Our Instagram account (integration)
  // - recipientId = Instagram user we're sending to

  senderId          String  @map("sender_id")
  senderUsername    String  @map("sender_username")
  recipientId       String? @map("recipient_id")
  recipientUsername String? @map("recipient_username")

  // Message content
  text        String  @db.Text
  attachments String? // Array of attachment objects

  // Timestamps
  timestamp DateTime // Instagram's timestamp
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Reply tracking (for INCOMING messages)
  isReplied      Boolean   @default(false) @map("is_replied")
  repliedAt      DateTime? @map("replied_at")
  replyMessageId String?   @map("reply_message_id") // ID of our reply message

  // For OUTGOING messages
  deliveryStatus DeliveryStatus? @map("delivery_status") // SENT, DELIVERED, READ, FAILED
  failureReason  String?         @map("failure_reason")

  // Workflow tracking
  workflowExecutionId  String? @map("workflow_execution_id")
  triggeredByCommentId String? @map("triggered_by_comment_id") // If DM was triggered by comment

  // Metadata
  metadata Json? // Additional data (webhook info, etc)

  @@index([integrationId, direction])
  @@index([integrationId, isReplied])
  @@index([threadId])
  @@index([senderId])
  @@index([recipientId])
  @@index([timestamp])
  @@map("direct_message")
  @@schema("zosmed")
}

enum MessageDirection {
  INCOMING // User -> Our Account
  OUTGOING // Our Account -> User

  @@schema("zosmed")
}

enum DeliveryStatus {
  SENT
  DELIVERED
  READ
  FAILED

  @@schema("zosmed")
}

enum ReplyStatus {
  PENDING
  SUCCESS
  FAILED
  SKIPPED

  @@schema("zosmed")
}

model Comment {
  id                  String       @id @default(cuid())
  integrationId       String       @map("integration_id")
  integration         Integration  @relation(fields: [integrationId], references: [id], onDelete: Cascade)
  commentId           String       @unique @map("comment_id")
  postId              String       @map("post_id")
  parentId            String?      @map("parent_id")
  userId              String       @map("user_id")
  username            String
  text                String       @db.Text
  isReplied           Boolean      @default(false) @map("is_replied")
  repliedAt           DateTime?    @map("replied_at")
  replyText           String?      @map("reply_text") @db.Text
  replyStatus         ReplyStatus? @map("reply_status")
  dmSent              Boolean      @default(false) @map("dm_sent")
  dmSentAt            DateTime?    @map("dm_sent_at")
  workflowExecutionId String?      @map("workflow_execution_id")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([integrationId, isReplied])
  @@index([postId])
  @@map("comment")
  @@schema("zosmed")
}

model Workflow {
  id             String                   @id @default(cuid())
  userId         String                   @map("user_id")
  integrationId  String                   @map("integration_id")
  integration    Integration              @relation(fields: [integrationId], references: [id], onDelete: Cascade)
  name           String
  description    String?
  definition     String
  isActive       Boolean                  @default(true) @map("is_active")
  triggerType    WorkflowTriggerType      @map("trigger_type")
  lastRunAt      DateTime?                @map("last_run_at")
  lastRunStatus  WorkflowExecutionStatus? @map("last_run_status")
  totalRuns      Int                      @default(0) @map("total_runs")
  successfulRuns Int                      @default(0) @map("successful_runs")
  executions     WorkflowExecution[]
  createdAt      DateTime                 @default(now()) @map("created_at")
  updatedAt      DateTime                 @updatedAt @map("updated_at")
  User           User                     @relation(fields: [userId], references: [id])

  @@unique([name, userId])
  @@index([integrationId, isActive])
  @@map("workflow")
  @@schema("zosmed")
}

enum WorkflowTriggerType {
  COMMENT_RECEIVED
  DM_RECEIVED

  @@schema("zosmed")
}

enum WorkflowStatus {
  DRAFT
  ACTIVE
  PAUSED
  ERROR

  @@schema("zosmed")
}

model WorkflowExecution {
  id              String                  @id @default(cuid())
  workflowId      String                  @map("workflow_id")
  userId          String                  @map("user_id")
  trigger         String
  status          WorkflowExecutionStatus @default(PENDING)
  createdAt       DateTime                @default(now()) @map("created_at")
  startedAt       DateTime?               @map("started_at")
  completedAt     DateTime?               @map("completed_at")
  definition      String                  @default("{}")
  creditsConsumed Int                     @default(0) @map("credits_consumed")
  phases          ExecutionPhase[]
  workflow        Workflow                @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  metadata        String?
  errorMessage    String?                 @map("error_message")

  @@map("workflow_execution")
  @@schema("zosmed")
}

enum WorkflowExecutionStatus {
  PENDING
  RUNNING
  SUCCESS
  FAILED
  CANCELLED

  @@schema("zosmed")
}

model ExecutionPhase {
  id                  String               @id @default(cuid())
  userId              String               @map("user_id")
  status              ExecutionPhaseStatus @default(PENDING)
  number              Int
  node                String
  name                String
  startedAt           DateTime?            @map("started_at")
  completedAt         DateTime?            @map("completed_at")
  inputs              String?
  outputs             String?
  errorMessage        String?              @map("error_message")
  creditsConsumed     Int?                 @map("credits_consumed")
  workflowExecutionId String               @map("workflow_execution_id")
  execution           WorkflowExecution    @relation(fields: [workflowExecutionId], references: [id], onDelete: Cascade)
  logs                ExecutionLog[]

  @@map("execution_phase")
  @@schema("zosmed")
}

enum ExecutionPhaseStatus {
  PENDING
  RUNNING
  SUCCESS
  FAILED
  SKIPPED

  @@schema("zosmed")
}

model ExecutionLog {
  id               String         @id @default(cuid())
  logLevel         LogLevel       @default(INFO) @map("log_level")
  message          String
  timestamp        DateTime       @default(now())
  executionPhaseId String         @map("execution_phase_id")
  executionPhase   ExecutionPhase @relation(fields: [executionPhaseId], references: [id], onDelete: Cascade)

  @@map("execution_log")
  @@schema("zosmed")
}

enum LogLevel {
  DEBUG
  INFO
  WARNING
  ERROR

  @@schema("zosmed")
}

model WorkflowTemplate {
  id          String  @id @default(cuid())
  name        String
  description String
  category    String // e.g., "Sales", "Support", "Community"
  definition  String
  isPremium   Boolean @default(false) @map("is_premium")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("workflow_template")
  @@schema("zosmed")
}

model Notification {
  id     String  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user   User?   @relation(fields: [userId], references: [id])
  userId String? @map("user_id")

  channel  String // "email", "push", "sms", etc.
  title    String? // Optional: for email subject or push title
  content  String // Message content (text or JSON string)
  metadata Json? // JSON: additional data (email to, token, etc.)

  status     String  @default("pending") // "pending", "sent", "failed", "processing"
  retryCount Int     @default(0) @map("retry_count") // Retry count
  error      String?

  isSeen      Boolean   @default(false) @map("is_seen")
  scheduledAt DateTime? @map("scheduled_at") // Optional: scheduled send time
  sentAt      DateTime? @map("sent_at")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([status, scheduledAt])
  @@map("notification")
  @@schema("zosmed")
}

model UsageTracking {
  id             String      @id @default(cuid())
  userId         String      @map("user_id")
  integrationId  String      @map("integration_id")
  user           User        @relation(fields: [userId], references: [id])
  integration    Integration @relation(fields: [integrationId], references: [id])
  date           DateTime    @db.Date
  dmSent         Int         @default(0) @map("dm_sent")
  commentReplied Int         @default(0) @map("comment_replied")
  workflowRuns   Int         @default(0) @map("workflow_runs")
  createdAt      DateTime    @default(now()) @map("created_at")

  @@unique([userId, integrationId, date])
  @@index([userId, date])
  @@map("usage_tracking")
  @@schema("zosmed")
}

model WebhookEvent {
  id           String    @id @default(cuid())
  source       String // instagram, facebook, etc
  status       String // received, processed, failed
  payload      String
  headers      String?
  metadata     String? // processing details
  errorMessage String?   @map("error_message")
  receivedAt   DateTime  @default(now()) @map("received_at")
  processedAt  DateTime? @map("processed_at")

  @@index([source, status])
  @@index([receivedAt])
  @@map("webhook_event")
  @@schema("zosmed")
}

model WebhookError {
  id             String   @id @default(cuid())
  webhookEventId String   @map("webhook_event_id")
  integrationId  String   @map("integration_id")
  field          String // comments, messages, etc
  error          String
  payload        Json
  createdAt      DateTime @default(now()) @map("created_at")

  @@index([webhookEventId])
  @@index([integrationId])
  @@map("webhook_error")
  @@schema("zosmed")
}

model DiscountCode {
  id                String          @id @default(cuid())
  code              String          @unique
  type              DiscountType    @default(PERCENTAGE)
  value             Float // 50 for 50% or 50000 for Rp 50k
  description       String?
  validFrom         DateTime        @default(now()) @map("valid_from")
  validUntil        DateTime?       @map("valid_until")
  maxUses           Int?            @map("max_uses") // null = unlimited
  currentUses       Int             @default(0) @map("current_uses")
  minPurchaseAmount Float?          @map("min_purchase_amount") // Minimum order amount
  applicablePlans   String[]        @map("applicable_plans") // ["STARTER", "PRO"] or empty for all
  isActive          Boolean         @default(true) @map("is_active")
  waitinglistId     String?         @unique @map("waitinglist_id")
  waitinglist       Waitinglist?    @relation(fields: [waitinglistId], references: [id])
  usages            DiscountUsage[]
  createdAt         DateTime        @default(now()) @map("created_at")
  updatedAt         DateTime        @updatedAt @map("updated_at")

  @@index([code, isActive])
  @@map("discount_code")
  @@schema("zosmed")
}

enum DiscountType {
  PERCENTAGE // 50% off
  FIXED // Rp 50k off

  @@schema("zosmed")
}

model DiscountUsage {
  id             String       @id @default(cuid())
  discountId     String       @map("discount_id")
  discount       DiscountCode @relation(fields: [discountId], references: [id])
  userId         String       @map("user_id")
  user           User         @relation(fields: [userId], references: [id])
  appliedAt      DateTime     @default(now()) @map("applied_at")
  orderAmount    Float        @map("order_amount")
  discountAmount Float        @map("discount_amount")
  subscriptionId String?      @map("subscription_id")

  @@unique([discountId, userId]) // One discount per user
  @@map("discount_usage")
  @@schema("zosmed")
}

model PricingPlan {
  id                 String         @id @default(cuid())
  name               String         @unique // FREE, STARTER, PRO
  displayName        String         @map("display_name") // "Free", "Starter", "Pro"
  description        String?
  price              Float          @default(0)
  currency           String         @default("IDR")
  period             PricingPeriod  @default(MONTHLY)
  color              String // "from-blue-500 to-cyan-500"
  bgColor            String         @map("bg_color") // "bg-blue-50"
  borderColor        String         @map("border_color") // "border-blue-200"
  popular            Boolean        @default(false)
  badge              String? // "BEST VALUE", "RECOMMENDED"
  maxAccounts        Int            @default(1) @map("max_accounts")
  maxDMPerMonth      Int            @default(100) @map("max_dm_per_month")
  maxAIReplyPerMonth Int            @default(0) @map("max_ai_reply_per_month")
  features           Json // Array of feature objects
  isActive           Boolean        @default(true) @map("is_active")
  sortOrder          Int            @default(0) @map("sort_order")
  subscriptions      Subscription[]

  createdAt      DateTime        @default(now()) @map("created_at")
  updatedAt      DateTime        @updatedAt @map("updated_at")
  payment        Payment[]
  recurringPlans RecurringPlan[]

  @@index([isActive, sortOrder])
  @@map("pricing_plan")
  @@schema("zosmed")
}

enum PricingPeriod {
  MONTHLY
  QUARTERLY
  YEARLY
  LIFETIME

  @@schema("zosmed")
}

model Payment {
  id                String        @id @default(cuid())
  userId            String        @map("user_id")
  user              User          @relation(fields: [userId], references: [id])
  planId            String?       @map("plan_id")
  plan              PricingPlan?  @relation(fields: [planId], references: [id])
  externalId        String        @unique @map("external_id")
  xenditInvoiceId   String?       @unique @map("xendit_invoice_id")
  xenditInvoiceUrl  String?       @map("xendit_invoice_url")
  xenditRecurringId String?       @map("xendit_recurring_id")
  amount            Float
  currency          String        @default("IDR")
  status            PaymentStatus @default(PENDING)
  paymentMethod     String?       @map("payment_method")
  paymentChannel    String?       @map("payment_channel")
  discountCode      String?       @map("discount_code")
  discountAmount    Float?        @map("discount_amount")
  createdAt         DateTime      @default(now()) @map("created_at")
  paidAt            DateTime?     @map("paid_at")
  expiredAt         DateTime?     @map("expired_at")
  metadata          Json?
  recurringCycleId  String?       @map("recurring_cycle_id")
  isRecurring       Boolean       @default(false) @map("is_recurring")

  @@index([userId, status])
  @@index([externalId])
  @@map("payment")
  @@schema("zosmed")
}

enum PaymentStatus {
  PENDING
  SUCCESS
  FAILED
  EXPIRED
  REFUNDED
  ABANDONED

  @@schema("zosmed")
}

model RecurringPlan {
  id               String      @id @default(cuid())
  userId           String      @map("user_id")
  user             User        @relation(fields: [userId], references: [id])
  pricingPlanId    String      @map("pricing_plan_id")
  pricingPlan      PricingPlan @relation(fields: [pricingPlanId], references: [id])
  xenditPlanId     String      @unique @map("xendit_plan_id")
  xenditCustomerId String      @map("xendit_customer_id")
  paymentMethodId  String?     @map("payment_method_id")
  status           String // PENDING_ACTIVATION, CREATED, ACTIVE, PAUSED, INACTIVE
  amount           Float
  discountCode     String?     @map("discount_code")
  discountAmount   Float?      @map("discount_amount")
  activatedAt      DateTime?   @map("activated_at")
  pausedAt         DateTime?   @map("paused_at")
  deactivatedAt    DateTime?   @map("deactivated_at")
  metadata         Json?
  createdAt        DateTime    @default(now()) @map("created_at")
  updatedAt        DateTime    @updatedAt @map("updated_at")

  subscription   Subscription? @relation(fields: [subscriptionId], references: [id])
  subscriptionId String?       @unique @map("subscription_id") @db.Uuid

  @@index([userId, status])
  @@map("recurring_plan")
  @@schema("zosmed")
}

model RecurringCycle {
  id            String    @id @default(cuid())
  cycleId       String    @unique @map("cycle_id")
  planId        String    @map("plan_id")
  amount        Float
  currency      String    @default("IDR")
  status        String // SCHEDULED, PROCESSING, SUCCEEDED, FAILED
  scheduledAt   DateTime  @map("scheduled_at")
  succeededAt   DateTime? @map("succeeded_at")
  failedAt      DateTime? @map("failed_at")
  failureReason String?   @map("failure_reason")
  cycleNumber   Int       @map("cycle_number")
  metadata      Json?
  createdAt     DateTime  @default(now()) @map("created_at")

  @@index([planId, status])
  @@map("recurring_cycle")
  @@schema("zosmed")
}

model PaymentMethod {
  id                    String    @id @default(cuid())
  userId                String    @map("user_id")
  user                  User      @relation(fields: [userId], references: [id])
  xenditPaymentMethodId String    @unique @map("xendit_payment_method_id")
  type                  String // CARD, EWALLET, DIRECT_DEBIT
  channelCode           String?   @map("channel_code") // OVO, DANA, BCA, etc
  status                String // ACTIVE, INACTIVE, PENDING_ACTIVATION, EXPIRED, FAILED
  isDefault             Boolean   @default(false) @map("is_default")
  lastUsedAt            DateTime? @map("last_used_at")
  activatedAt           DateTime? @map("activated_at")
  expiredAt             DateTime? @map("expired_at")
  failureCode           String?   @map("failure_code")
  metadata              Json?
  createdAt             DateTime  @default(now()) @map("created_at")
  updatedAt             DateTime  @updatedAt @map("updated_at")

  @@index([userId, status])
  @@index([xenditPaymentMethodId])
  @@map("payment_method")
  @@schema("zosmed")
}

model PaymentChannel {
  id          String             @id @default(cuid())
  channelCode String             @unique @map("channel_code") // BCA, OVO, QRIS, dll
  channelName String             @map("channel_name") // Display name
  type        PaymentChannelType @default(VIRTUAL_ACCOUNT)
  category    PaymentCategory    @default(BANK_TRANSFER)

  // Configuration
  isActive           Boolean @default(true) @map("is_active")
  isOneTimeEnabled   Boolean @default(true) @map("is_one_time_enabled")
  isRecurringEnabled Boolean @default(false) @map("is_recurring_enabled")

  // Display settings
  logo            String? // URL or icon name
  backgroundColor String? @map("bg_color")
  textColor       String? @map("text_color")
  sortOrder       Int     @default(0) @map("sort_order")

  // Limits & fees
  minAmount     Float? @map("min_amount")
  maxAmount     Float? @map("max_amount")
  processingFee Float? @map("processing_fee") // Fixed fee
  percentageFee Float? @map("percentage_fee") // Percentage fee

  // Business rules
  allowedForPlans String[] @map("allowed_for_plans") // ["FREE", "STARTER", "PRO"] or empty for all
  description     String? // Admin notes
  customerMessage String?  @map("customer_message") // Message shown to customer

  // Metadata
  xenditChannelCode String? @map("xendit_channel_code") // Actual Xendit channel code
  metadata          Json? // Additional config

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([isActive, sortOrder])
  @@index([type, isActive])
  @@index([isOneTimeEnabled])
  @@index([isRecurringEnabled])
  @@map("payment_channel")
  @@schema("zosmed")
}

enum PaymentChannelType {
  VIRTUAL_ACCOUNT // BCA, BNI, BRI, Mandiri
  EWALLET // OVO, DANA, LinkAja, ShopeePay
  QR_CODE // QRIS
  CREDIT_CARD // Credit/Debit cards
  BANK_TRANSFER // Direct bank transfer
  DIRECT_DEBIT // Recurring payments

  @@schema("zosmed")
}

enum PaymentCategory {
  BANK_TRANSFER // Traditional banking
  DIGITAL_WALLET // E-wallet solutions
  CARD_PAYMENT // Credit/debit cards
  QR_PAYMENT // QR code based

  @@schema("zosmed")
}
